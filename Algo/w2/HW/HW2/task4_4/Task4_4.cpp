/*
Автор: Щербаков Игорь
4_4.
Даны неотрицательные целые числа n,k и массив целых чисел из [0..10^9] размера n. Требуется найти k-ю порядковую статистику. т.е. напечатать число, которое бы стояло на позиции с индексом k (0..n-1) в отсортированном массиве. Напишите нерекурсивный алгоритм.
Требования к дополнительной памяти: O(n). Требуемое среднее время работы: O(n).
Функцию Partition следует реализовывать методом прохода двумя итераторами в одном направлении. Описание для случая прохода от начала массива к концу:
Выбирается опорный элемент. Опорный элемент меняется с последним элементом массива.
Во время работы Partition в начале массива содержатся элементы, не бОльшие опорного. Затем располагаются элементы, строго бОльшие опорного. В конце массива лежат нерассмотренные элементы. Последним элементом лежит опорный.
Итератор (индекс) i указывает на начало группы элементов, строго бОльших опорного.
Итератор j больше i, итератор j указывает на первый нерассмотренный элемент.
Шаг алгоритма. Рассматривается элемент, на который указывает j. Если он больше опорного, то сдвигаем j.
Если он не больше опорного, то меняем a[i] и a[j] местами, сдвигаем i и сдвигаем j.
В конце работы алгоритма меняем опорный и элемент, на который указывает итератор i.

Реализуйте стратегию выбора опорного элемента “случайный элемент”. Функцию Partition реализуйте методом прохода двумя итераторами от конца массива к началу.
*/

#include <iostream>
using namespace std;

//выбор опорного элемента
int GetPivot(int min, int max) {
	int variable_index = rand() % (max - min + 1) + min;
	return variable_index;
}

class IsGrInt {
public:
	IsGrInt() {};
	bool operator ()(const int& l, int& r) {
		return l >= r;
	}
};

template <class T, class IsGr>
int Partition(T* arr, int l, int r, IsGr isgr) {
	int pivot_point = GetPivot(l, r);
	//опорный элемент в начало
	if (l != r)
		std::swap(arr[pivot_point], arr[l]);
	//проходим массив с конца
	T x = arr[l];
	int i = r+1;
	for (int j = r; j >= l; j--) {
		if (isgr(arr[j], x))
			std::swap(arr[--i], arr[j]);
	}
	return i;
}

template <class T, class IsGr>
int KStat(T* arr, int n, int k, IsGr isgr) {
	int left = 0;
	int right = n - 1;
	while (true) {
		int part = Partition(arr, left, right, isgr);
		if (part < k)
			left = part + 1;
		else
			if (part > k)
				right = part - 1;
			else
				return k;
	}
}

int main() {
	int n, k;
	cin >> n >> k;
	int* arr = new int[n];
	for (int i = 0; i < n; i++) {
		cin >> arr[i];
	}

	int k_ind = KStat(arr, n, k, IsGrInt());
	cout << arr[k_ind];

	delete[] arr;
	return 0;
}