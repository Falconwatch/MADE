/*
Автор: Щербаков Игорь
4_4.
Даны неотрицательные целые числа n,k и массив целых чисел из [0..10^9] размера n. Требуется найти k-ю порядковую статистику. т.е. напечатать число, которое бы стояло на позиции с индексом k (0..n-1) в отсортированном массиве. Напишите нерекурсивный алгоритм.
Требования к дополнительной памяти: O(n). Требуемое среднее время работы: O(n).
Функцию Partition следует реализовывать методом прохода двумя итераторами в одном направлении. Описание для случая прохода от начала массива к концу:
Выбирается опорный элемент. Опорный элемент меняется с последним элементом массива.
Во время работы Partition в начале массива содержатся элементы, не бОльшие опорного. Затем располагаются элементы, строго бОльшие опорного. В конце массива лежат нерассмотренные элементы. Последним элементом лежит опорный.
Итератор (индекс) i указывает на начало группы элементов, строго бОльших опорного.
Итератор j больше i, итератор j указывает на первый нерассмотренный элемент.
Шаг алгоритма. Рассматривается элемент, на который указывает j. Если он больше опорного, то сдвигаем j.
Если он не больше опорного, то меняем a[i] и a[j] местами, сдвигаем i и сдвигаем j.
В конце работы алгоритма меняем опорный и элемент, на который указывает итератор i.

Реализуйте стратегию выбора опорного элемента “случайный элемент”. Функцию Partition реализуйте методом прохода двумя итераторами от конца массива к началу.
*/

#include <iostream>
using namespace std;


int GetPartitioner(int min, int max) {
	int variable_index = rand() % (max - min + 1) + min;
	return variable_index;
}

int Partition(int* arr, int l, int r) {
	int p = GetPartitioner(l, r);
	if (l != r)
		std::swap(arr[p], arr[r]);
	int x = arr[r];
	int i = l - 1;
	for (int j = l; j <= r; j++) {
		if (arr[j] <= x)
			std::swap(arr[++i], arr[j]);
	}
	return i;
}


int KStat(int* arr, int n, int k) {
	int left = 0, right = n - 1;
	while (true) {
		int pos = Partition(arr, left, right);
		if (pos < k)
			left = pos + 1;
		else
			if (pos > k)
				right = pos - 1;
			else
				return k;
	}
}

int main() {
	int n, k;
	cin >> n >> k;
	int* arr = new int[n];
	for (int i = 0; i < n; i++) {
		cin >> arr[i];
	}

	int k_ind = KStat(arr, n, k);
	cout << arr[k_ind];


	delete[] arr;
	return 0;
}